半写半抄数据结构 - python实现
========================================

1. 栈 - 实现运算符优先级
---------------------------

 只要是有运算，运算符优先级的实现都是必须的。但真没想到，就想A+B这么简单的东西，里面也有一堆学问。
 
 *运算符，如+, -, *, /;*
 
 *操作数，如A，B，C，1，2，3*
 
1.1 中缀，前缀和后缀表达式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

(1) 中缀
:::::::::
	
	A + B，运算符在操作数A，B的中间，就是中缀。
	
	A + B * C，也是中缀。
 
(2) 前缀
:::::::::
 
	以A+B*C为例，把运算符如*位移到对应操作符如BC前，就是前缀；
 
	A + B * C -> + A * BC
 
(3) 后缀
:::::::::

	继续以A+B*C为例，把运算符如*位移至对应的操作数如BC后，就是后缀；
 
	A + B * C -> ABC * +
 
	不管运算符如何放置，也不会影响操作数ABC的顺序。
 
 
1.2 带括号的中缀，前缀和后缀表达式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 
(1) 中缀
:::::::::
 
	( A + B ) * C
 
(2) 前缀
:::::::::
	
	运算符位移至"("的位置并删除匹配的")"
 
	( A + B ) * C -> * + ABC
 
(3) 后缀
:::::::::
	
	运算符位移至")"的位置并删除匹配的"("
 
	( A + B ) * C -> AB + C *
	
	
1.3 Python实现
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

- 若之前没实现栈，可以先用pythonds这个库；
- 这里只实现了加减乘除；

(1) 解析转换，中缀至后缀

	- 创建一个operator_list的空栈保存运算符；创建一个result_set空列表作为最后结果输入
	
	- 循环扫描formula：
	::
	
	  如果是操作数，直接加入列表result_set
	  如果是运算符，push到operator_list
	  如果是"("，push到opertor_list
	  如果是")", pop，直到pop到前面最后一个（说匹配的也可以）"("，运算符加入result_set末尾
	  如果是运算符，先把operator_list中等于或高于其优先级的运算符pop和加入result_set，后再push进operator_list


(2) 转换后计算

	- 创建一个calculating_list的空栈保存运算符
	
	- 循环扫描converted_result：
	::
	  
	  如果是操作数，直接加入列表calculating_list
	  如果是运算符，pop出calculating_list的顶部头两个操作数，就是pop两次。然后调用do_math计算，其结果放回calculating_list

	  
代码：https://github.com/pk00749/Example_Python/blob/master/Test_Stack.py

2.  
---------------------------

	To be continue
   

  